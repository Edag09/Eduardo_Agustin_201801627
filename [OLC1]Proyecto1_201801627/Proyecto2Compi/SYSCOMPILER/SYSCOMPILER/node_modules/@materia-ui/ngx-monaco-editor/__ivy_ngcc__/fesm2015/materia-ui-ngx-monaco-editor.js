import { __decorate, __param, __metadata, __rest } from 'tslib';
import { NgZone, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, TemplateRef, ViewContainerRef, Directive, EventEmitter, Input, Output, ViewChild, ElementRef, Component, ChangeDetectionStrategy, forwardRef, NgModule } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil, filter, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';

/// <reference path="monaco.d.ts" />
import * as ɵngcc0 from '@angular/core';

const _c0 = ["editor"];
const _c1 = ["diffEditor"];
const _c2 = ".monaco-editor[_ngcontent-%COMP%] {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n\n}\n.editor-container[_ngcontent-%COMP%] {\n\toverflow: hidden;\n\tposition: relative;\n\tdisplay: table;\n\twidth: 100%;\n  height: 100%;\n  min-width: 0;\n}";
const MONACO_PATH = 'MONACO_PATH';

let MonacoEditorLoaderService = class MonacoEditorLoaderService {
    constructor(ngZone, monacoPathConfig) {
        this.ngZone = ngZone;
        this.monacoPathConfig = monacoPathConfig;
        this.isMonacoLoaded$ = new BehaviorSubject(false);
        this._monacoPath = 'assets/monaco-editor/min/vs';
        if (window.monacoEditorAlreadyInitialized) {
            ngZone.run(() => this.isMonacoLoaded$.next(true));
            return;
        }
        window.monacoEditorAlreadyInitialized = true;
        if (this.monacoPathConfig) {
            this.monacoPath = this.monacoPathConfig;
        }
        this.loadMonaco();
    }
    set monacoPath(value) {
        if (value) {
            this._monacoPath = value;
        }
    }
    loadMonaco() {
        const onGotAmdLoader = () => {
            let vsPath = this._monacoPath;
            window.amdRequire = window.require;
            const isElectron = !!this.nodeRequire;
            if (isElectron) {
                // Restore node require in window
                window.require = this.nodeRequire;
                const path = window.require('path');
                vsPath = path.resolve(window.__dirname, this._monacoPath);
            }
            window.amdRequire.config({ paths: { vs: vsPath } });
            // Load monaco
            window.amdRequire(['vs/editor/editor.main'], () => {
                this.ngZone.run(() => this.isMonacoLoaded$.next(true));
            });
        };
        // Check if AMD loader already available
        const isAmdLoaderAvailable = !!window.amdRequire;
        if (isAmdLoaderAvailable) {
            return onGotAmdLoader();
        }
        const isElectron = !!window.require;
        if (isElectron) {
            this.addElectronFixScripts();
            this.nodeRequire = window.require;
        }
        const loaderScript = document.createElement('script');
        loaderScript.type = 'text/javascript';
        loaderScript.src = `${this._monacoPath}/loader.js`;
        loaderScript.addEventListener('load', onGotAmdLoader);
        document.body.appendChild(loaderScript);
    }
    addElectronFixScripts() {
        const electronFixScript = document.createElement('script');
        // workaround monaco-css not understanding the environment
        const inlineScript = document.createTextNode('self.module = undefined;');
        // workaround monaco-typescript not understanding the environment
        const inlineScript2 = document.createTextNode('self.process.browser = true;');
        electronFixScript.appendChild(inlineScript);
        electronFixScript.appendChild(inlineScript2);
        document.body.appendChild(electronFixScript);
    }
};
MonacoEditorLoaderService.ɵfac = function MonacoEditorLoaderService_Factory(t) { return new (t || MonacoEditorLoaderService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(MONACO_PATH, 8)); };
MonacoEditorLoaderService.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MONACO_PATH,] }] }
];
MonacoEditorLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function MonacoEditorLoaderService_Factory() { return new MonacoEditorLoaderService(ɵɵinject(NgZone), ɵɵinject("MONACO_PATH", 8)); }, token: MonacoEditorLoaderService, providedIn: "root" });
MonacoEditorLoaderService = __decorate([ __param(1, Optional()), __param(1, Inject(MONACO_PATH)),
    __metadata("design:paramtypes", [NgZone, String])
], MonacoEditorLoaderService);

let MonacoEditorLoaderDirective = class MonacoEditorLoaderDirective {
    constructor(templateRef, viewContainer, monacoEditorLoaderService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.monacoEditorLoaderService = monacoEditorLoaderService;
        this.isMonacoLoaded$ = this.monacoEditorLoaderService.isMonacoLoaded$.asObservable();
        this.destroyed$ = new Subject();
    }
    ngOnInit() {
        this.isMonacoLoaded$.pipe(takeUntil(this.destroyed$)).subscribe((loaded) => {
            if (!loaded) {
                return this.viewContainer.clear();
            }
            this.viewContainer.createEmbeddedView(this.templateRef);
        });
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
};
MonacoEditorLoaderDirective.ɵfac = function MonacoEditorLoaderDirective_Factory(t) { return new (t || MonacoEditorLoaderDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService)); };
MonacoEditorLoaderDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MonacoEditorLoaderDirective, selectors: [["", "ngxLoadMonacoEditor", ""]] });
MonacoEditorLoaderDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: MonacoEditorLoaderService }
];
MonacoEditorLoaderDirective = __decorate([ __metadata("design:paramtypes", [TemplateRef,
        ViewContainerRef,
        MonacoEditorLoaderService])
], MonacoEditorLoaderDirective);

var MonacoEditorComponent_1;
let MonacoEditorComponent = MonacoEditorComponent_1 = class MonacoEditorComponent {
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
        this.propagateChange = (_) => { };
    }
    get model() {
        return this.editor && this.editor.getModel();
    }
    get modelMarkers() {
        return this.model && monaco.editor.getModelMarkers({
            resource: this.model.uri
        });
    }
    ngOnInit() {
        this.monacoLoader.isMonacoLoaded$.pipe(filter(isLoaded => isLoaded), take(1)).subscribe(() => {
            this.initEditor();
        });
    }
    ngOnChanges(changes) {
        if (this.editor && changes.options && !changes.options.firstChange) {
            const _a = changes.options.currentValue, { language: toLanguage, theme: toTheme } = _a, options = __rest(_a, ["language", "theme"]);
            const { language: fromLanguage, theme: fromTheme } = changes.options.previousValue;
            if (fromLanguage !== toLanguage) {
                monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');
            }
            if (fromTheme !== toTheme) {
                monaco.editor.setTheme(toTheme);
            }
            this.editor.updateOptions(options);
        }
        if (this.editor && changes.uri) {
            const toUri = changes.uri.currentValue;
            const fromUri = changes.uri.previousValue;
            if (fromUri && !toUri || !fromUri && toUri || toUri && fromUri && toUri.path !== fromUri.path) {
                const value = this.editor.getValue();
                if (this.modelUriInstance) {
                    this.modelUriInstance.dispose();
                }
                let existingModel;
                if (toUri) {
                    existingModel = monaco.editor.getModels().find((model) => model.uri.path === toUri.path);
                }
                this.modelUriInstance = existingModel ? existingModel : monaco.editor.createModel(value, this.options.language || 'text', this.uri);
                this.editor.setModel(this.modelUriInstance);
            }
        }
    }
    writeValue(value) {
        this.value = value;
        if (this.editor && value) {
            this.editor.setValue(value);
        }
        else if (this.editor) {
            this.editor.setValue('');
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    validate() {
        return !this.parsedError ? null : {
            monaco: {
                value: this.parsedError.split('|'),
            }
        };
    }
    registerOnValidatorChange(fn) {
        this.onErrorStatusChange = fn;
    }
    initEditor() {
        const options = {
            value: [this.value].join('\n'),
            language: 'text',
            automaticLayout: true,
            scrollBeyondLastLine: false,
            theme: 'vc'
        };
        this.editor = monaco.editor.create(this.editorContent.nativeElement, this.options ? Object.assign(Object.assign({}, options), this.options) : options);
        this.registerEditorListeners();
        this.init.emit(this.editor);
    }
    registerEditorListeners() {
        this.editor.onDidChangeModelContent(() => {
            this.propagateChange(this.editor.getValue());
        });
        this.editor.onDidChangeModelDecorations(() => {
            const currentParsedError = this.modelMarkers.map(({ message }) => message).join('|');
            const hasValidationStatusChanged = this.parsedError !== currentParsedError;
            if (hasValidationStatusChanged) {
                this.parsedError = currentParsedError;
                this.onErrorStatusChange();
            }
        });
        this.editor.onDidBlurEditorText(() => {
            this.onTouched();
        });
    }
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
};
MonacoEditorComponent.ɵfac = function MonacoEditorComponent_Factory(t) { return new (t || MonacoEditorComponent)(ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService)); };
MonacoEditorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MonacoEditorComponent, selectors: [["ngx-monaco-editor"]], viewQuery: function MonacoEditorComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editorContent = _t.first);
    } }, inputs: { options: "options", uri: "uri" }, outputs: { init: "init" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MonacoEditorComponent_1),
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => MonacoEditorComponent_1),
                multi: true
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 0, consts: [["fxFlex", "", 1, "editor-container"], ["container", ""], [1, "monaco-editor"], ["editor", ""]], template: function MonacoEditorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelement(2, "div", 2, 3);
        ɵngcc0.ɵɵelementEnd();
    } }, styles: [_c2], changeDetection: 0 });
MonacoEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], MonacoEditorComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MonacoEditorComponent.prototype, "uri", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MonacoEditorComponent.prototype, "init", void 0);
__decorate([
    ViewChild('editor', { static: true }),
    __metadata("design:type", ElementRef)
], MonacoEditorComponent.prototype, "editorContent", void 0);
MonacoEditorComponent = MonacoEditorComponent_1 = __decorate([ __metadata("design:paramtypes", [MonacoEditorLoaderService])
], MonacoEditorComponent);

let MonacoDiffEditorComponent = class MonacoDiffEditorComponent {
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
    }
    ngOnInit() {
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter(isLoaded => isLoaded), take(1)).subscribe(() => {
            this.initMonaco();
        });
    }
    ngOnChanges(changes) {
        if (this.editor && ((changes.code && !changes.code.firstChange) || (changes.modified && !changes.modified.firstChange))) {
            const modified = monaco.editor.createModel(this.modified);
            const original = monaco.editor.createModel(this.original);
            this.editor.setModel({
                original,
                modified
            });
        }
        if (this.editor &&
            changes.options &&
            !changes.options.firstChange) {
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    }
    initMonaco() {
        let opts = {
            readOnly: true,
            automaticLayout: true,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.createDiffEditor(this.container, opts);
        const original = monaco.editor.createModel(this.original);
        const modified = monaco.editor.createModel(this.modified);
        this.editor.setModel({
            original,
            modified
        });
        this.editor.layout();
        this.init.emit(this.editor);
    }
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
};
MonacoDiffEditorComponent.ɵfac = function MonacoDiffEditorComponent_Factory(t) { return new (t || MonacoDiffEditorComponent)(ɵngcc0.ɵɵdirectiveInject(MonacoEditorLoaderService)); };
MonacoDiffEditorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MonacoDiffEditorComponent, selectors: [["ngx-monaco-diff-editor"]], viewQuery: function MonacoDiffEditorComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editorContent = _t.first);
    } }, inputs: { original: "original", modified: "modified", options: "options" }, outputs: { init: "init" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 0, consts: [["fxFlex", "", 1, "editor-container"], ["container", ""], [1, "monaco-editor"], ["diffEditor", ""]], template: function MonacoDiffEditorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelement(2, "div", 2, 3);
        ɵngcc0.ɵɵelementEnd();
    } }, styles: [_c2], changeDetection: 0 });
MonacoDiffEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], MonacoDiffEditorComponent.prototype, "original", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MonacoDiffEditorComponent.prototype, "modified", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MonacoDiffEditorComponent.prototype, "options", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MonacoDiffEditorComponent.prototype, "init", void 0);
__decorate([
    ViewChild('diffEditor', { static: true }),
    __metadata("design:type", ElementRef)
], MonacoDiffEditorComponent.prototype, "editorContent", void 0);
MonacoDiffEditorComponent = __decorate([ __metadata("design:paramtypes", [MonacoEditorLoaderService])
], MonacoDiffEditorComponent);

let MonacoEditorModule = class MonacoEditorModule {
};
MonacoEditorModule.ɵfac = function MonacoEditorModule_Factory(t) { return new (t || MonacoEditorModule)(); };
MonacoEditorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MonacoEditorModule });
MonacoEditorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MonacoEditorLoaderService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MONACO_PATH]
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MonacoEditorLoaderDirective, [{
        type: Directive,
        args: [{ selector: '[ngxLoadMonacoEditor]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ViewContainerRef }, { type: MonacoEditorLoaderService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MonacoEditorComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-monaco-editor',
                template: `<div #container class="editor-container" fxFlex>
		<div
			#editor
			class="monaco-editor"
		></div>
</div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MonacoEditorComponent_1),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => MonacoEditorComponent_1),
                        multi: true
                    }
                ],
                styles: [`
.monaco-editor {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;

}
.editor-container {
	overflow: hidden;
	position: relative;
	display: table;
	width: 100%;
  height: 100%;
  min-width: 0;
}`]
            }]
    }], function () { return [{ type: MonacoEditorLoaderService }]; }, { init: [{
            type: Output
        }], options: [{
            type: Input
        }], uri: [{
            type: Input
        }], editorContent: [{
            type: ViewChild,
            args: ['editor', { static: true }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MonacoDiffEditorComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-monaco-diff-editor',
                template: `<div #container class="editor-container" fxFlex>
		<div
			#diffEditor
			class="monaco-editor"
		></div>
</div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
.monaco-editor {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;

}
.editor-container {
	overflow: hidden;
	position: relative;
	display: table;
	width: 100%;
  height: 100%;
  min-width: 0;
}`]
            }]
    }], function () { return [{ type: MonacoEditorLoaderService }]; }, { init: [{
            type: Output
        }], original: [{
            type: Input
        }], modified: [{
            type: Input
        }], options: [{
            type: Input
        }], editorContent: [{
            type: ViewChild,
            args: ['diffEditor', { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MonacoEditorModule, { declarations: [MonacoEditorLoaderDirective, MonacoEditorComponent, MonacoDiffEditorComponent], exports: [MonacoEditorLoaderDirective, MonacoEditorComponent, MonacoDiffEditorComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MonacoEditorModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [
                    MonacoEditorLoaderDirective,
                    MonacoEditorComponent,
                    MonacoDiffEditorComponent
                ],
                exports: [
                    MonacoEditorLoaderDirective,
                    MonacoEditorComponent,
                    MonacoDiffEditorComponent
                ],
                entryComponents: [MonacoEditorComponent, MonacoDiffEditorComponent]
            }]
    }], null, null); })();

/*
 * Public API Surface of materia-monaco-editor-lib
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MONACO_PATH, MonacoDiffEditorComponent, MonacoEditorComponent, MonacoEditorLoaderDirective, MonacoEditorLoaderService, MonacoEditorModule };

//# sourceMappingURL=materia-ui-ngx-monaco-editor.js.map