import { __decorate, __param, __metadata, __rest } from 'tslib';
import { NgZone, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, TemplateRef, ViewContainerRef, Directive, EventEmitter, Input, Output, ViewChild, ElementRef, Component, ChangeDetectionStrategy, forwardRef, NgModule } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil, filter, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';

/// <reference path="monaco.d.ts" />
const MONACO_PATH = 'MONACO_PATH';

let MonacoEditorLoaderService = class MonacoEditorLoaderService {
    constructor(ngZone, monacoPathConfig) {
        this.ngZone = ngZone;
        this.monacoPathConfig = monacoPathConfig;
        this.isMonacoLoaded$ = new BehaviorSubject(false);
        this._monacoPath = 'assets/monaco-editor/min/vs';
        if (window.monacoEditorAlreadyInitialized) {
            ngZone.run(() => this.isMonacoLoaded$.next(true));
            return;
        }
        window.monacoEditorAlreadyInitialized = true;
        if (this.monacoPathConfig) {
            this.monacoPath = this.monacoPathConfig;
        }
        this.loadMonaco();
    }
    set monacoPath(value) {
        if (value) {
            this._monacoPath = value;
        }
    }
    loadMonaco() {
        const onGotAmdLoader = () => {
            let vsPath = this._monacoPath;
            window.amdRequire = window.require;
            const isElectron = !!this.nodeRequire;
            if (isElectron) {
                // Restore node require in window
                window.require = this.nodeRequire;
                const path = window.require('path');
                vsPath = path.resolve(window.__dirname, this._monacoPath);
            }
            window.amdRequire.config({ paths: { vs: vsPath } });
            // Load monaco
            window.amdRequire(['vs/editor/editor.main'], () => {
                this.ngZone.run(() => this.isMonacoLoaded$.next(true));
            });
        };
        // Check if AMD loader already available
        const isAmdLoaderAvailable = !!window.amdRequire;
        if (isAmdLoaderAvailable) {
            return onGotAmdLoader();
        }
        const isElectron = !!window.require;
        if (isElectron) {
            this.addElectronFixScripts();
            this.nodeRequire = window.require;
        }
        const loaderScript = document.createElement('script');
        loaderScript.type = 'text/javascript';
        loaderScript.src = `${this._monacoPath}/loader.js`;
        loaderScript.addEventListener('load', onGotAmdLoader);
        document.body.appendChild(loaderScript);
    }
    addElectronFixScripts() {
        const electronFixScript = document.createElement('script');
        // workaround monaco-css not understanding the environment
        const inlineScript = document.createTextNode('self.module = undefined;');
        // workaround monaco-typescript not understanding the environment
        const inlineScript2 = document.createTextNode('self.process.browser = true;');
        electronFixScript.appendChild(inlineScript);
        electronFixScript.appendChild(inlineScript2);
        document.body.appendChild(electronFixScript);
    }
};
MonacoEditorLoaderService.ctorParameters = () => [
    { type: NgZone },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MONACO_PATH,] }] }
];
MonacoEditorLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function MonacoEditorLoaderService_Factory() { return new MonacoEditorLoaderService(ɵɵinject(NgZone), ɵɵinject("MONACO_PATH", 8)); }, token: MonacoEditorLoaderService, providedIn: "root" });
MonacoEditorLoaderService = __decorate([
    Injectable({ providedIn: 'root' }),
    __param(1, Optional()), __param(1, Inject(MONACO_PATH)),
    __metadata("design:paramtypes", [NgZone, String])
], MonacoEditorLoaderService);

let MonacoEditorLoaderDirective = class MonacoEditorLoaderDirective {
    constructor(templateRef, viewContainer, monacoEditorLoaderService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.monacoEditorLoaderService = monacoEditorLoaderService;
        this.isMonacoLoaded$ = this.monacoEditorLoaderService.isMonacoLoaded$.asObservable();
        this.destroyed$ = new Subject();
    }
    ngOnInit() {
        this.isMonacoLoaded$.pipe(takeUntil(this.destroyed$)).subscribe((loaded) => {
            if (!loaded) {
                return this.viewContainer.clear();
            }
            this.viewContainer.createEmbeddedView(this.templateRef);
        });
    }
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
};
MonacoEditorLoaderDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: MonacoEditorLoaderService }
];
MonacoEditorLoaderDirective = __decorate([
    Directive({ selector: '[ngxLoadMonacoEditor]' }),
    __metadata("design:paramtypes", [TemplateRef,
        ViewContainerRef,
        MonacoEditorLoaderService])
], MonacoEditorLoaderDirective);

var MonacoEditorComponent_1;
let MonacoEditorComponent = MonacoEditorComponent_1 = class MonacoEditorComponent {
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
        this.propagateChange = (_) => { };
    }
    get model() {
        return this.editor && this.editor.getModel();
    }
    get modelMarkers() {
        return this.model && monaco.editor.getModelMarkers({
            resource: this.model.uri
        });
    }
    ngOnInit() {
        this.monacoLoader.isMonacoLoaded$.pipe(filter(isLoaded => isLoaded), take(1)).subscribe(() => {
            this.initEditor();
        });
    }
    ngOnChanges(changes) {
        if (this.editor && changes.options && !changes.options.firstChange) {
            const _a = changes.options.currentValue, { language: toLanguage, theme: toTheme } = _a, options = __rest(_a, ["language", "theme"]);
            const { language: fromLanguage, theme: fromTheme } = changes.options.previousValue;
            if (fromLanguage !== toLanguage) {
                monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');
            }
            if (fromTheme !== toTheme) {
                monaco.editor.setTheme(toTheme);
            }
            this.editor.updateOptions(options);
        }
        if (this.editor && changes.uri) {
            const toUri = changes.uri.currentValue;
            const fromUri = changes.uri.previousValue;
            if (fromUri && !toUri || !fromUri && toUri || toUri && fromUri && toUri.path !== fromUri.path) {
                const value = this.editor.getValue();
                if (this.modelUriInstance) {
                    this.modelUriInstance.dispose();
                }
                let existingModel;
                if (toUri) {
                    existingModel = monaco.editor.getModels().find((model) => model.uri.path === toUri.path);
                }
                this.modelUriInstance = existingModel ? existingModel : monaco.editor.createModel(value, this.options.language || 'text', this.uri);
                this.editor.setModel(this.modelUriInstance);
            }
        }
    }
    writeValue(value) {
        this.value = value;
        if (this.editor && value) {
            this.editor.setValue(value);
        }
        else if (this.editor) {
            this.editor.setValue('');
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    validate() {
        return !this.parsedError ? null : {
            monaco: {
                value: this.parsedError.split('|'),
            }
        };
    }
    registerOnValidatorChange(fn) {
        this.onErrorStatusChange = fn;
    }
    initEditor() {
        const options = {
            value: [this.value].join('\n'),
            language: 'text',
            automaticLayout: true,
            scrollBeyondLastLine: false,
            theme: 'vc'
        };
        this.editor = monaco.editor.create(this.editorContent.nativeElement, this.options ? Object.assign(Object.assign({}, options), this.options) : options);
        this.registerEditorListeners();
        this.init.emit(this.editor);
    }
    registerEditorListeners() {
        this.editor.onDidChangeModelContent(() => {
            this.propagateChange(this.editor.getValue());
        });
        this.editor.onDidChangeModelDecorations(() => {
            const currentParsedError = this.modelMarkers.map(({ message }) => message).join('|');
            const hasValidationStatusChanged = this.parsedError !== currentParsedError;
            if (hasValidationStatusChanged) {
                this.parsedError = currentParsedError;
                this.onErrorStatusChange();
            }
        });
        this.editor.onDidBlurEditorText(() => {
            this.onTouched();
        });
    }
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
};
MonacoEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], MonacoEditorComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MonacoEditorComponent.prototype, "uri", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MonacoEditorComponent.prototype, "init", void 0);
__decorate([
    ViewChild('editor', { static: true }),
    __metadata("design:type", ElementRef)
], MonacoEditorComponent.prototype, "editorContent", void 0);
MonacoEditorComponent = MonacoEditorComponent_1 = __decorate([
    Component({
        selector: 'ngx-monaco-editor',
        template: `<div #container class="editor-container" fxFlex>
		<div
			#editor
			class="monaco-editor"
		></div>
</div>`,
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MonacoEditorComponent_1),
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => MonacoEditorComponent_1),
                multi: true,
            }
        ],
        styles: [`
.monaco-editor {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;

}
.editor-container {
	overflow: hidden;
	position: relative;
	display: table;
	width: 100%;
  height: 100%;
  min-width: 0;
}`]
    }),
    __metadata("design:paramtypes", [MonacoEditorLoaderService])
], MonacoEditorComponent);

let MonacoDiffEditorComponent = class MonacoDiffEditorComponent {
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
    }
    ngOnInit() {
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter(isLoaded => isLoaded), take(1)).subscribe(() => {
            this.initMonaco();
        });
    }
    ngOnChanges(changes) {
        if (this.editor && ((changes.code && !changes.code.firstChange) || (changes.modified && !changes.modified.firstChange))) {
            const modified = monaco.editor.createModel(this.modified);
            const original = monaco.editor.createModel(this.original);
            this.editor.setModel({
                original,
                modified
            });
        }
        if (this.editor &&
            changes.options &&
            !changes.options.firstChange) {
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    }
    initMonaco() {
        let opts = {
            readOnly: true,
            automaticLayout: true,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.createDiffEditor(this.container, opts);
        const original = monaco.editor.createModel(this.original);
        const modified = monaco.editor.createModel(this.modified);
        this.editor.setModel({
            original,
            modified
        });
        this.editor.layout();
        this.init.emit(this.editor);
    }
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
};
MonacoDiffEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], MonacoDiffEditorComponent.prototype, "original", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MonacoDiffEditorComponent.prototype, "modified", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MonacoDiffEditorComponent.prototype, "options", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MonacoDiffEditorComponent.prototype, "init", void 0);
__decorate([
    ViewChild('diffEditor', { static: true }),
    __metadata("design:type", ElementRef)
], MonacoDiffEditorComponent.prototype, "editorContent", void 0);
MonacoDiffEditorComponent = __decorate([
    Component({
        selector: 'ngx-monaco-diff-editor',
        template: `<div #container class="editor-container" fxFlex>
		<div
			#diffEditor
			class="monaco-editor"
		></div>
</div>`,
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [`
.monaco-editor {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;

}
.editor-container {
	overflow: hidden;
	position: relative;
	display: table;
	width: 100%;
  height: 100%;
  min-width: 0;
}`]
    }),
    __metadata("design:paramtypes", [MonacoEditorLoaderService])
], MonacoDiffEditorComponent);

let MonacoEditorModule = class MonacoEditorModule {
};
MonacoEditorModule = __decorate([
    NgModule({
        imports: [],
        declarations: [
            MonacoEditorLoaderDirective,
            MonacoEditorComponent,
            MonacoDiffEditorComponent
        ],
        exports: [
            MonacoEditorLoaderDirective,
            MonacoEditorComponent,
            MonacoDiffEditorComponent
        ],
        entryComponents: [MonacoEditorComponent, MonacoDiffEditorComponent]
    })
], MonacoEditorModule);

/*
 * Public API Surface of materia-monaco-editor-lib
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MONACO_PATH, MonacoDiffEditorComponent, MonacoEditorComponent, MonacoEditorLoaderDirective, MonacoEditorLoaderService, MonacoEditorModule };
//# sourceMappingURL=materia-ui-ngx-monaco-editor.js.map
