var MonacoEditorComponent_1;
import { __decorate, __metadata, __rest } from "tslib";
import { Component, ViewChild, ElementRef, EventEmitter, Input, ChangeDetectionStrategy, forwardRef, Output } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { filter, take } from 'rxjs/operators';
import { MonacoEditorLoaderService } from '../../services/monaco-editor-loader.service';
let MonacoEditorComponent = MonacoEditorComponent_1 = class MonacoEditorComponent {
    constructor(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
        this.propagateChange = (_) => { };
    }
    get model() {
        return this.editor && this.editor.getModel();
    }
    get modelMarkers() {
        return this.model && monaco.editor.getModelMarkers({
            resource: this.model.uri
        });
    }
    ngOnInit() {
        this.monacoLoader.isMonacoLoaded$.pipe(filter(isLoaded => isLoaded), take(1)).subscribe(() => {
            this.initEditor();
        });
    }
    ngOnChanges(changes) {
        if (this.editor && changes.options && !changes.options.firstChange) {
            const _a = changes.options.currentValue, { language: toLanguage, theme: toTheme } = _a, options = __rest(_a, ["language", "theme"]);
            const { language: fromLanguage, theme: fromTheme } = changes.options.previousValue;
            if (fromLanguage !== toLanguage) {
                monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');
            }
            if (fromTheme !== toTheme) {
                monaco.editor.setTheme(toTheme);
            }
            this.editor.updateOptions(options);
        }
        if (this.editor && changes.uri) {
            const toUri = changes.uri.currentValue;
            const fromUri = changes.uri.previousValue;
            if (fromUri && !toUri || !fromUri && toUri || toUri && fromUri && toUri.path !== fromUri.path) {
                const value = this.editor.getValue();
                if (this.modelUriInstance) {
                    this.modelUriInstance.dispose();
                }
                let existingModel;
                if (toUri) {
                    existingModel = monaco.editor.getModels().find((model) => model.uri.path === toUri.path);
                }
                this.modelUriInstance = existingModel ? existingModel : monaco.editor.createModel(value, this.options.language || 'text', this.uri);
                this.editor.setModel(this.modelUriInstance);
            }
        }
    }
    writeValue(value) {
        this.value = value;
        if (this.editor && value) {
            this.editor.setValue(value);
        }
        else if (this.editor) {
            this.editor.setValue('');
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    validate() {
        return !this.parsedError ? null : {
            monaco: {
                value: this.parsedError.split('|'),
            }
        };
    }
    registerOnValidatorChange(fn) {
        this.onErrorStatusChange = fn;
    }
    initEditor() {
        const options = {
            value: [this.value].join('\n'),
            language: 'text',
            automaticLayout: true,
            scrollBeyondLastLine: false,
            theme: 'vc'
        };
        this.editor = monaco.editor.create(this.editorContent.nativeElement, this.options ? Object.assign(Object.assign({}, options), this.options) : options);
        this.registerEditorListeners();
        this.init.emit(this.editor);
    }
    registerEditorListeners() {
        this.editor.onDidChangeModelContent(() => {
            this.propagateChange(this.editor.getValue());
        });
        this.editor.onDidChangeModelDecorations(() => {
            const currentParsedError = this.modelMarkers.map(({ message }) => message).join('|');
            const hasValidationStatusChanged = this.parsedError !== currentParsedError;
            if (hasValidationStatusChanged) {
                this.parsedError = currentParsedError;
                this.onErrorStatusChange();
            }
        });
        this.editor.onDidBlurEditorText(() => {
            this.onTouched();
        });
    }
    ngOnDestroy() {
        if (this.editor) {
            this.editor.dispose();
        }
    }
};
MonacoEditorComponent.ctorParameters = () => [
    { type: MonacoEditorLoaderService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], MonacoEditorComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], MonacoEditorComponent.prototype, "uri", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], MonacoEditorComponent.prototype, "init", void 0);
__decorate([
    ViewChild('editor', { static: true }),
    __metadata("design:type", ElementRef)
], MonacoEditorComponent.prototype, "editorContent", void 0);
MonacoEditorComponent = MonacoEditorComponent_1 = __decorate([
    Component({
        selector: 'ngx-monaco-editor',
        template: `<div #container class="editor-container" fxFlex>
		<div
			#editor
			class="monaco-editor"
		></div>
</div>`,
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => MonacoEditorComponent_1),
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => MonacoEditorComponent_1),
                multi: true,
            }
        ],
        styles: [`
.monaco-editor {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;

}
.editor-container {
	overflow: hidden;
	position: relative;
	display: table;
	width: 100%;
  height: 100%;
  min-width: 0;
}`]
    }),
    __metadata("design:paramtypes", [MonacoEditorLoaderService])
], MonacoEditorComponent);
export { MonacoEditorComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9uYWNvLWVkaXRvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbWF0ZXJpYS11aS9uZ3gtbW9uYWNvLWVkaXRvci8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL21vbmFjby1lZGl0b3IvbW9uYWNvLWVkaXRvci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUNULFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUlaLEtBQUssRUFDTCx1QkFBdUIsRUFDdkIsVUFBVSxFQUVWLE1BQU0sRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFhLGFBQWEsRUFBb0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUNySCxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTlDLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBNEN4RixJQUFhLHFCQUFxQiw2QkFBbEMsTUFBYSxxQkFBcUI7SUF5QjlCLFlBQW9CLFlBQXVDO1FBQXZDLGlCQUFZLEdBQVosWUFBWSxDQUEyQjtRQXRCakQsU0FBSSxHQUE2QyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBVXRFLG9CQUFlLEdBQW9CLENBQUMsQ0FBTSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFZSSxDQUFDO0lBVmhFLElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQy9DLENBQUM7SUFFRCxJQUFJLFlBQVk7UUFDZCxPQUFPLElBQUksQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUM7WUFDakQsUUFBUSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRztTQUN6QixDQUFDLENBQUM7SUFDTCxDQUFDO0lBSUQsUUFBUTtRQUNKLElB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QUU7O2tEQUF1QjtBQUNyQjtJQUFULE1BQU0sRUFBRTs4QkFBTyxZQUFZO21EQUFrRDtBQUN6QztJQUFwQyxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQyxDQUFDOzhCQUFnQixVQUFVOzREQUFDO0FBSnRELHFCQUFxQjtJQXpDakMsU0FBUyxDQUFDO1FBQ1AsUUFBUSxFQUFFLG1CQUFtQjtRQUM3QixRQUFRLEVBQUU7Ozs7O09BS1A7UUFvQkgsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07UUFDL0MsU0FBUyxFQUFFO1lBQ1A7Z0JBQ0ksT0FBTyxFQUFFLGlCQUFpQjtnQkFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBcUIsQ0FBQztnQkFDcEQsS0FBSyxFQUFFLElBQUk7YUFDZDtZQUNEO2dCQUNJLE9BQU8sRUFBRSxhQUFhO2dCQUN0QixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFxQixDQUFDO2dCQUNwRCxLQUFLLEVBQUUsSUFBSTthQUNkO1NBQ0o7aUJBOUJHOzs7Ozs7Ozs7Ozs7Ozs7O0VBZ0JOO0tBZUQsQ0FBQztxQ0EwQm9DLHlCQUF5QjtHQXpCbEQscUJBQXFCLENBNklqQztTQTdJWSxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBWaWV3Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgT25Jbml0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgSW5wdXQsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgZm9yd2FyZFJlZixcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIE91dHB1dFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiwgVmFsaWRhdG9yLCBOR19WQUxJREFUT1JTLCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBNb25hY29FZGl0b3JMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbW9uYWNvLWVkaXRvci1sb2FkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBNb25hY29FZGl0b3JDb25zdHJ1Y3Rpb25PcHRpb25zLCBNb25hY29FZGl0b3JVcmksIE1vbmFjb1N0YW5kYWxvbmVDb2RlRWRpdG9yIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbmd4LW1vbmFjby1lZGl0b3InLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAjY29udGFpbmVyIGNsYXNzPVwiZWRpdG9yLWNvbnRhaW5lclwiIGZ4RmxleD5cblx0XHQ8ZGl2XG5cdFx0XHQjZWRpdG9yXG5cdFx0XHRjbGFzcz1cIm1vbmFjby1lZGl0b3JcIlxuXHRcdD48L2Rpdj5cbjwvZGl2PmAsXG4gICAgc3R5bGVzOiBbXG4gICAgICAgIGBcbi5tb25hY28tZWRpdG9yIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGJvdHRvbTogMDtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG5cbn1cbi5lZGl0b3ItY29udGFpbmVyIHtcblx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRkaXNwbGF5OiB0YWJsZTtcblx0d2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgbWluLXdpZHRoOiAwO1xufWBcbiAgICBdLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1vbmFjb0VkaXRvckNvbXBvbmVudCksXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTW9uYWNvRWRpdG9yQ29tcG9uZW50KSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICB9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBNb25hY29FZGl0b3JDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIHtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBNb25hY29FZGl0b3JDb25zdHJ1Y3Rpb25PcHRpb25zO1xuICAgIEBJbnB1dCgpIHVyaT86IE1vbmFjb0VkaXRvclVyaTtcbiAgICBAT3V0cHV0KCkgaW5pdDogRXZlbnRFbWl0dGVyPE1vbmFjb1N0YW5kYWxvbmVDb2RlRWRpdG9yPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICBAVmlld0NoaWxkKCdlZGl0b3InLCB7c3RhdGljOiB0cnVlfSkgZWRpdG9yQ29udGVudDogRWxlbWVudFJlZjtcblxuICAgIGVkaXRvcjogTW9uYWNvU3RhbmRhbG9uZUNvZGVFZGl0b3I7XG4gICAgbW9kZWxVcmlJbnN0YW5jZTogbW9uYWNvLmVkaXRvci5JVGV4dE1vZGVsO1xuICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgcGFyc2VkRXJyb3I6IHN0cmluZztcblxuICAgIHByaXZhdGUgb25Ub3VjaGVkOiAoKSA9PiB2b2lkO1xuICAgIHByaXZhdGUgb25FcnJvclN0YXR1c0NoYW5nZTogKCkgPT4gdm9pZDtcbiAgICBwcml2YXRlIHByb3BhZ2F0ZUNoYW5nZTogKF86IGFueSkgPT4gYW55ID0gKF86IGFueSkgPT4geyB9O1xuXG4gICAgZ2V0IG1vZGVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yICYmIHRoaXMuZWRpdG9yLmdldE1vZGVsKCk7XG4gICAgfVxuXG4gICAgZ2V0IG1vZGVsTWFya2VycygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsICYmIG1vbmFjby5lZGl0b3IuZ2V0TW9kZWxNYXJrZXJzKHtcbiAgICAgICAgcmVzb3VyY2U6IHRoaXMubW9kZWwudXJpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vbmFjb0xvYWRlcjogTW9uYWNvRWRpdG9yTG9hZGVyU2VydmljZSkgeyB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5tb25hY29Mb2FkZXIuaXNNb25hY29Mb2FkZWQkLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoaXNMb2FkZWQgPT4gaXNMb2FkZWQpLFxuICAgICAgICAgICAgdGFrZSgxKVxuICAgICAgICApLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmluaXRFZGl0b3IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IgJiYgY2hhbmdlcy5vcHRpb25zICYmICFjaGFuZ2VzLm9wdGlvbnMuZmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlOiB0b0xhbmd1YWdlLCB0aGVtZTogdG9UaGVtZSwgLi4ub3B0aW9ucyB9ID0gY2hhbmdlcy5vcHRpb25zLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlOiBmcm9tTGFuZ3VhZ2UsIHRoZW1lOiBmcm9tVGhlbWUgfSA9IGNoYW5nZXMub3B0aW9ucy5wcmV2aW91c1ZhbHVlO1xuICAgICAgICAgICAgaWYgKGZyb21MYW5ndWFnZSAhPT0gdG9MYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIG1vbmFjby5lZGl0b3Iuc2V0TW9kZWxMYW5ndWFnZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZ2V0TW9kZWwoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5sYW5ndWFnZSA/IHRoaXMub3B0aW9ucy5sYW5ndWFnZSA6ICd0ZXh0J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbVRoZW1lICE9PSB0b1RoZW1lKSB7XG4gICAgICAgICAgICAgICAgbW9uYWNvLmVkaXRvci5zZXRUaGVtZSh0b1RoZW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnVwZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yICYmIGNoYW5nZXMudXJpKSB7XG4gICAgICAgICAgY29uc3QgdG9VcmkgPSBjaGFuZ2VzLnVyaS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgY29uc3QgZnJvbVVyaSA9IGNoYW5nZXMudXJpLnByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgaWYgKGZyb21VcmkgJiYgIXRvVXJpIHx8ICFmcm9tVXJpICYmIHRvVXJpIHx8IHRvVXJpICYmIGZyb21VcmkgJiYgdG9VcmkucGF0aCAhPT0gZnJvbVVyaS5wYXRoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbFVyaUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHRoaXMubW9kZWxVcmlJbnN0YW5jZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdNb2RlbDtcbiAgICAgICAgICAgIGlmICh0b1VyaSkge1xuICAgICAgICAgICAgICBleGlzdGluZ01vZGVsID0gbW9uYWNvLmVkaXRvci5nZXRNb2RlbHMoKS5maW5kKChtb2RlbCkgPT4gbW9kZWwudXJpLnBhdGggPT09IHRvVXJpLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tb2RlbFVyaUluc3RhbmNlID0gZXhpc3RpbmdNb2RlbCA/IGV4aXN0aW5nTW9kZWwgOiBtb25hY28uZWRpdG9yLmNyZWF0ZU1vZGVsKHZhbHVlLCB0aGlzLm9wdGlvbnMubGFuZ3VhZ2UgfHwgJ3RleHQnLCB0aGlzLnVyaSk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRNb2RlbCh0aGlzLm1vZGVsVXJpSW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmVkaXRvciAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSgnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfVxuXG4gICAgdmFsaWRhdGUoKTogVmFsaWRhdGlvbkVycm9ycyB7XG4gICAgICAgIHJldHVybiAhdGhpcy5wYXJzZWRFcnJvciA/IG51bGwgOiB7XG4gICAgICAgICAgICBtb25hY286IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5wYXJzZWRFcnJvci5zcGxpdCgnfCcpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2U/KGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25FcnJvclN0YXR1c0NoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdEVkaXRvcigpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogTW9uYWNvRWRpdG9yQ29uc3RydWN0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBbdGhpcy52YWx1ZV0uam9pbignXFxuJyksXG4gICAgICAgICAgICBsYW5ndWFnZTogJ3RleHQnLFxuICAgICAgICAgICAgYXV0b21hdGljTGF5b3V0OiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsQmV5b25kTGFzdExpbmU6IGZhbHNlLFxuICAgICAgICAgICAgdGhlbWU6ICd2YydcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmVkaXRvciA9IG1vbmFjby5lZGl0b3IuY3JlYXRlKFxuICAgICAgICAgIHRoaXMuZWRpdG9yQ29udGVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgIHRoaXMub3B0aW9ucyA/IHsgLi4ub3B0aW9ucywgLi4udGhpcy5vcHRpb25zIH0gOiBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmluaXQuZW1pdCh0aGlzLmVkaXRvcik7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJFZGl0b3JMaXN0ZW5lcnMoKSB7XG4gICAgICB0aGlzLmVkaXRvci5vbkRpZENoYW5nZU1vZGVsQ29udGVudCgoKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMuZWRpdG9yLmdldFZhbHVlKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZWRpdG9yLm9uRGlkQ2hhbmdlTW9kZWxEZWNvcmF0aW9ucygoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFBhcnNlZEVycm9yID0gdGhpcy5tb2RlbE1hcmtlcnMubWFwKCh7IG1lc3NhZ2UgfSkgPT4gbWVzc2FnZSkuam9pbignfCcpO1xuICAgICAgICAgIGNvbnN0IGhhc1ZhbGlkYXRpb25TdGF0dXNDaGFuZ2VkID0gdGhpcy5wYXJzZWRFcnJvciAhPT0gY3VycmVudFBhcnNlZEVycm9yO1xuXG4gICAgICAgICAgaWYgKGhhc1ZhbGlkYXRpb25TdGF0dXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHRoaXMucGFyc2VkRXJyb3IgPSBjdXJyZW50UGFyc2VkRXJyb3I7XG4gICAgICAgICAgICAgIHRoaXMub25FcnJvclN0YXR1c0NoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmVkaXRvci5vbkRpZEJsdXJFZGl0b3JUZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19