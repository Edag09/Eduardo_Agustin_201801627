import { __decorate, __param, __metadata, __rest, __assign } from 'tslib';
import { NgZone, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, Injectable, TemplateRef, ViewContainerRef, Directive, EventEmitter, Input, Output, ViewChild, ElementRef, Component, ChangeDetectionStrategy, forwardRef, NgModule } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil, filter, take } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';

/// <reference path="monaco.d.ts" />
var MONACO_PATH = 'MONACO_PATH';

var MonacoEditorLoaderService = /** @class */ (function () {
    function MonacoEditorLoaderService(ngZone, monacoPathConfig) {
        var _this = this;
        this.ngZone = ngZone;
        this.monacoPathConfig = monacoPathConfig;
        this.isMonacoLoaded$ = new BehaviorSubject(false);
        this._monacoPath = 'assets/monaco-editor/min/vs';
        if (window.monacoEditorAlreadyInitialized) {
            ngZone.run(function () { return _this.isMonacoLoaded$.next(true); });
            return;
        }
        window.monacoEditorAlreadyInitialized = true;
        if (this.monacoPathConfig) {
            this.monacoPath = this.monacoPathConfig;
        }
        this.loadMonaco();
    }
    Object.defineProperty(MonacoEditorLoaderService.prototype, "monacoPath", {
        set: function (value) {
            if (value) {
                this._monacoPath = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    MonacoEditorLoaderService.prototype.loadMonaco = function () {
        var _this = this;
        var onGotAmdLoader = function () {
            var vsPath = _this._monacoPath;
            window.amdRequire = window.require;
            var isElectron = !!_this.nodeRequire;
            if (isElectron) {
                // Restore node require in window
                window.require = _this.nodeRequire;
                var path = window.require('path');
                vsPath = path.resolve(window.__dirname, _this._monacoPath);
            }
            window.amdRequire.config({ paths: { vs: vsPath } });
            // Load monaco
            window.amdRequire(['vs/editor/editor.main'], function () {
                _this.ngZone.run(function () { return _this.isMonacoLoaded$.next(true); });
            });
        };
        // Check if AMD loader already available
        var isAmdLoaderAvailable = !!window.amdRequire;
        if (isAmdLoaderAvailable) {
            return onGotAmdLoader();
        }
        var isElectron = !!window.require;
        if (isElectron) {
            this.addElectronFixScripts();
            this.nodeRequire = window.require;
        }
        var loaderScript = document.createElement('script');
        loaderScript.type = 'text/javascript';
        loaderScript.src = this._monacoPath + "/loader.js";
        loaderScript.addEventListener('load', onGotAmdLoader);
        document.body.appendChild(loaderScript);
    };
    MonacoEditorLoaderService.prototype.addElectronFixScripts = function () {
        var electronFixScript = document.createElement('script');
        // workaround monaco-css not understanding the environment
        var inlineScript = document.createTextNode('self.module = undefined;');
        // workaround monaco-typescript not understanding the environment
        var inlineScript2 = document.createTextNode('self.process.browser = true;');
        electronFixScript.appendChild(inlineScript);
        electronFixScript.appendChild(inlineScript2);
        document.body.appendChild(electronFixScript);
    };
    MonacoEditorLoaderService.ctorParameters = function () { return [
        { type: NgZone },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MONACO_PATH,] }] }
    ]; };
    MonacoEditorLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function MonacoEditorLoaderService_Factory() { return new MonacoEditorLoaderService(ɵɵinject(NgZone), ɵɵinject("MONACO_PATH", 8)); }, token: MonacoEditorLoaderService, providedIn: "root" });
    MonacoEditorLoaderService = __decorate([
        Injectable({ providedIn: 'root' }),
        __param(1, Optional()), __param(1, Inject(MONACO_PATH)),
        __metadata("design:paramtypes", [NgZone, String])
    ], MonacoEditorLoaderService);
    return MonacoEditorLoaderService;
}());

var MonacoEditorLoaderDirective = /** @class */ (function () {
    function MonacoEditorLoaderDirective(templateRef, viewContainer, monacoEditorLoaderService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.monacoEditorLoaderService = monacoEditorLoaderService;
        this.isMonacoLoaded$ = this.monacoEditorLoaderService.isMonacoLoaded$.asObservable();
        this.destroyed$ = new Subject();
    }
    MonacoEditorLoaderDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.isMonacoLoaded$.pipe(takeUntil(this.destroyed$)).subscribe(function (loaded) {
            if (!loaded) {
                return _this.viewContainer.clear();
            }
            _this.viewContainer.createEmbeddedView(_this.templateRef);
        });
    };
    MonacoEditorLoaderDirective.prototype.ngOnDestroy = function () {
        this.destroyed$.next();
        this.destroyed$.complete();
    };
    MonacoEditorLoaderDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: MonacoEditorLoaderService }
    ]; };
    MonacoEditorLoaderDirective = __decorate([
        Directive({ selector: '[ngxLoadMonacoEditor]' }),
        __metadata("design:paramtypes", [TemplateRef,
            ViewContainerRef,
            MonacoEditorLoaderService])
    ], MonacoEditorLoaderDirective);
    return MonacoEditorLoaderDirective;
}());

var MonacoEditorComponent = /** @class */ (function () {
    function MonacoEditorComponent(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
        this.propagateChange = function (_) { };
    }
    MonacoEditorComponent_1 = MonacoEditorComponent;
    Object.defineProperty(MonacoEditorComponent.prototype, "model", {
        get: function () {
            return this.editor && this.editor.getModel();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MonacoEditorComponent.prototype, "modelMarkers", {
        get: function () {
            return this.model && monaco.editor.getModelMarkers({
                resource: this.model.uri
            });
        },
        enumerable: true,
        configurable: true
    });
    MonacoEditorComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.monacoLoader.isMonacoLoaded$.pipe(filter(function (isLoaded) { return isLoaded; }), take(1)).subscribe(function () {
            _this.initEditor();
        });
    };
    MonacoEditorComponent.prototype.ngOnChanges = function (changes) {
        if (this.editor && changes.options && !changes.options.firstChange) {
            var _a = changes.options.currentValue, toLanguage = _a.language, toTheme = _a.theme, options = __rest(_a, ["language", "theme"]);
            var _b = changes.options.previousValue, fromLanguage = _b.language, fromTheme = _b.theme;
            if (fromLanguage !== toLanguage) {
                monaco.editor.setModelLanguage(this.editor.getModel(), this.options && this.options.language ? this.options.language : 'text');
            }
            if (fromTheme !== toTheme) {
                monaco.editor.setTheme(toTheme);
            }
            this.editor.updateOptions(options);
        }
        if (this.editor && changes.uri) {
            var toUri_1 = changes.uri.currentValue;
            var fromUri = changes.uri.previousValue;
            if (fromUri && !toUri_1 || !fromUri && toUri_1 || toUri_1 && fromUri && toUri_1.path !== fromUri.path) {
                var value = this.editor.getValue();
                if (this.modelUriInstance) {
                    this.modelUriInstance.dispose();
                }
                var existingModel = void 0;
                if (toUri_1) {
                    existingModel = monaco.editor.getModels().find(function (model) { return model.uri.path === toUri_1.path; });
                }
                this.modelUriInstance = existingModel ? existingModel : monaco.editor.createModel(value, this.options.language || 'text', this.uri);
                this.editor.setModel(this.modelUriInstance);
            }
        }
    };
    MonacoEditorComponent.prototype.writeValue = function (value) {
        this.value = value;
        if (this.editor && value) {
            this.editor.setValue(value);
        }
        else if (this.editor) {
            this.editor.setValue('');
        }
    };
    MonacoEditorComponent.prototype.registerOnChange = function (fn) {
        this.propagateChange = fn;
    };
    MonacoEditorComponent.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    MonacoEditorComponent.prototype.validate = function () {
        return !this.parsedError ? null : {
            monaco: {
                value: this.parsedError.split('|'),
            }
        };
    };
    MonacoEditorComponent.prototype.registerOnValidatorChange = function (fn) {
        this.onErrorStatusChange = fn;
    };
    MonacoEditorComponent.prototype.initEditor = function () {
        var options = {
            value: [this.value].join('\n'),
            language: 'text',
            automaticLayout: true,
            scrollBeyondLastLine: false,
            theme: 'vc'
        };
        this.editor = monaco.editor.create(this.editorContent.nativeElement, this.options ? __assign(__assign({}, options), this.options) : options);
        this.registerEditorListeners();
        this.init.emit(this.editor);
    };
    MonacoEditorComponent.prototype.registerEditorListeners = function () {
        var _this = this;
        this.editor.onDidChangeModelContent(function () {
            _this.propagateChange(_this.editor.getValue());
        });
        this.editor.onDidChangeModelDecorations(function () {
            var currentParsedError = _this.modelMarkers.map(function (_a) {
                var message = _a.message;
                return message;
            }).join('|');
            var hasValidationStatusChanged = _this.parsedError !== currentParsedError;
            if (hasValidationStatusChanged) {
                _this.parsedError = currentParsedError;
                _this.onErrorStatusChange();
            }
        });
        this.editor.onDidBlurEditorText(function () {
            _this.onTouched();
        });
    };
    MonacoEditorComponent.prototype.ngOnDestroy = function () {
        if (this.editor) {
            this.editor.dispose();
        }
    };
    var MonacoEditorComponent_1;
    MonacoEditorComponent.ctorParameters = function () { return [
        { type: MonacoEditorLoaderService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], MonacoEditorComponent.prototype, "options", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], MonacoEditorComponent.prototype, "uri", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MonacoEditorComponent.prototype, "init", void 0);
    __decorate([
        ViewChild('editor', { static: true }),
        __metadata("design:type", ElementRef)
    ], MonacoEditorComponent.prototype, "editorContent", void 0);
    MonacoEditorComponent = MonacoEditorComponent_1 = __decorate([
        Component({
            selector: 'ngx-monaco-editor',
            template: "<div #container class=\"editor-container\" fxFlex>\n\t\t<div\n\t\t\t#editor\n\t\t\tclass=\"monaco-editor\"\n\t\t></div>\n</div>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return MonacoEditorComponent_1; }),
                    multi: true
                },
                {
                    provide: NG_VALIDATORS,
                    useExisting: forwardRef(function () { return MonacoEditorComponent_1; }),
                    multi: true,
                }
            ],
            styles: ["\n.monaco-editor {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n\n}\n.editor-container {\n\toverflow: hidden;\n\tposition: relative;\n\tdisplay: table;\n\twidth: 100%;\n  height: 100%;\n  min-width: 0;\n}"]
        }),
        __metadata("design:paramtypes", [MonacoEditorLoaderService])
    ], MonacoEditorComponent);
    return MonacoEditorComponent;
}());

var MonacoDiffEditorComponent = /** @class */ (function () {
    function MonacoDiffEditorComponent(monacoLoader) {
        this.monacoLoader = monacoLoader;
        this.init = new EventEmitter();
    }
    MonacoDiffEditorComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.container = this.editorContent.nativeElement;
        this.monacoLoader.isMonacoLoaded$.pipe(filter(function (isLoaded) { return isLoaded; }), take(1)).subscribe(function () {
            _this.initMonaco();
        });
    };
    MonacoDiffEditorComponent.prototype.ngOnChanges = function (changes) {
        if (this.editor && ((changes.code && !changes.code.firstChange) || (changes.modified && !changes.modified.firstChange))) {
            var modified = monaco.editor.createModel(this.modified);
            var original = monaco.editor.createModel(this.original);
            this.editor.setModel({
                original: original,
                modified: modified
            });
        }
        if (this.editor &&
            changes.options &&
            !changes.options.firstChange) {
            if (changes.options.previousValue.theme !== changes.options.currentValue.theme) {
                monaco.editor.setTheme(changes.options.currentValue.theme);
            }
            this.editor.updateOptions(changes.options.currentValue);
        }
    };
    MonacoDiffEditorComponent.prototype.initMonaco = function () {
        var opts = {
            readOnly: true,
            automaticLayout: true,
            theme: 'vc'
        };
        if (this.options) {
            opts = Object.assign({}, opts, this.options);
        }
        this.editor = monaco.editor.createDiffEditor(this.container, opts);
        var original = monaco.editor.createModel(this.original);
        var modified = monaco.editor.createModel(this.modified);
        this.editor.setModel({
            original: original,
            modified: modified
        });
        this.editor.layout();
        this.init.emit(this.editor);
    };
    MonacoDiffEditorComponent.prototype.ngOnDestroy = function () {
        if (this.editor) {
            this.editor.dispose();
        }
    };
    MonacoDiffEditorComponent.ctorParameters = function () { return [
        { type: MonacoEditorLoaderService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], MonacoDiffEditorComponent.prototype, "original", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], MonacoDiffEditorComponent.prototype, "modified", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], MonacoDiffEditorComponent.prototype, "options", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MonacoDiffEditorComponent.prototype, "init", void 0);
    __decorate([
        ViewChild('diffEditor', { static: true }),
        __metadata("design:type", ElementRef)
    ], MonacoDiffEditorComponent.prototype, "editorContent", void 0);
    MonacoDiffEditorComponent = __decorate([
        Component({
            selector: 'ngx-monaco-diff-editor',
            template: "<div #container class=\"editor-container\" fxFlex>\n\t\t<div\n\t\t\t#diffEditor\n\t\t\tclass=\"monaco-editor\"\n\t\t></div>\n</div>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: ["\n.monaco-editor {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n\n}\n.editor-container {\n\toverflow: hidden;\n\tposition: relative;\n\tdisplay: table;\n\twidth: 100%;\n  height: 100%;\n  min-width: 0;\n}"]
        }),
        __metadata("design:paramtypes", [MonacoEditorLoaderService])
    ], MonacoDiffEditorComponent);
    return MonacoDiffEditorComponent;
}());

var MonacoEditorModule = /** @class */ (function () {
    function MonacoEditorModule() {
    }
    MonacoEditorModule = __decorate([
        NgModule({
            imports: [],
            declarations: [
                MonacoEditorLoaderDirective,
                MonacoEditorComponent,
                MonacoDiffEditorComponent
            ],
            exports: [
                MonacoEditorLoaderDirective,
                MonacoEditorComponent,
                MonacoDiffEditorComponent
            ],
            entryComponents: [MonacoEditorComponent, MonacoDiffEditorComponent]
        })
    ], MonacoEditorModule);
    return MonacoEditorModule;
}());

/*
 * Public API Surface of materia-monaco-editor-lib
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MONACO_PATH, MonacoDiffEditorComponent, MonacoEditorComponent, MonacoEditorLoaderDirective, MonacoEditorLoaderService, MonacoEditorModule };
//# sourceMappingURL=materia-ui-ngx-monaco-editor.js.map
